# 泛型编程

我们在编写程序的时候总是要把一些通用的功能抽象出来。比如说，我们设计了一个排序的算法，我们一般不会直接在每个需要排序的地方都针对特定的问题把同一个排序算法用程序实现一遍。我们通常会把这个算法抽象成一个子函数，把需要摆排序的数据作为函数的参数。因为算法的实现与具体数据无关，同一个算法可以方便的应用到不同的数据上。比如，同一个排序算法即可以对数组\[1,3,2]排序，也可以对组数组\[5,6,4]排序。

泛型编程是一种抽象度更高的编程风格。使用泛型抽象和编写出来的算法，不但不依赖与具体的数据，甚至也不依赖于具体的数据类型。比如，同一个排序函数不但可以给一组整数排序，也可以给一组字符串排序，还可以以按大小给一组苹果排序，也可以按成绩给一组学生排序等等。由上可知，编程语言要支持泛型编程，一个前提条件是，使用这个语言能够编写出一个可以接受可以接受不同数据类型参数的函数是一个前提。

LabVIEW 中的一些函数是支持泛型的，比如。。。

变体行不行，


编程语言主要通过两种方式来支持泛型编程：

一种是以 Java 为代表的类型擦除技术（erasure）。  当编译器对带有泛型的 Java 代码进行编译时，它会去执行类型检查和类型推断，然后生成普通的不带泛型的字节码，这种字节码可以被一般的 Java 虚拟机接收并执行，这种被称为擦

　　可见，编译器可以在对源程序（带有泛型的 Java 代码）进行编译时使用泛型类型信息保证类型安全，同时在生成的字节码当中，将这些类型信息清除掉。 

　　如在代码中定义的​​List<object>​​和​​List<String>​​等类型，在编译后都会编程List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。

另一种是以 C++ 为代表的代码插入技术。

　　C++泛型跟虚函数的运行时多态机制不同，泛型支持的静态多态，当类型信息可得的时候，利用编译期多态能够获得最大的效率和灵活性。当具体的类型信息不可得，就必须诉诸运行期多态了，即虚函数支持的动态多态。

　　对于C++泛型，每个实际类型都已被指明的泛型都会有独立的编码产生，也就是说​​list<int>​​和​​list<string>​​生成的是不同的代码，编译程序会在此时确保类型安全性。由于知道对象确切的类型，所以编译器进行代码生成的时候就不用运用RTTI，这使得泛型效率跟手动编码一样高。 

　　显然这样的做法增加了代码空间，相比运行时多态，是以空间换时间。
