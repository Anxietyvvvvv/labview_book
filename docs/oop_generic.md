# 泛型编程

## 基础知识
我们在编写程序的时候总是要把一些通用的功能抽象出来。比如说，我们设计了一个排序的算法，我们一般不会直接在每个需要排序的地方都针对特定的问题把同一个排序算法用程序实现一遍。我们通常会把这个算法抽象成一个子函数，把需要摆排序的数据作为函数的参数。因为算法的实现与具体数据无关，同一个算法可以方便的应用到不同的数据上。比如，同一个排序算法即可以对数组\[1,3,2]排序，也可以对组数组\[5,6,4]排序。

泛型编程是一种抽象度更高的编程风格。使用泛型抽象和编写出来的算法，不但不依赖与具体的数据，甚至也不依赖于具体的数据类型。比如，同一个排序函数不但可以给一组整数排序，也可以给一组字符串排序，还可以以按大小给一组苹果排序，也可以按成绩给一组学生排序等等。由上可知，编程语言要支持泛型编程，一个前提条件是，使用这个语言能够编写出一个可以接受可以接受不同数据类型参数的函数是一个前提。

LabVIEW 中的很多函数是支持泛型的，比如加法函数，可以接收数值类型的数据，也可以接受簇或者数组类型的数据；还有数组相关的函数，可以用来操作数值数组，一可以操作字符串数组。

![images_2/z045.png](images_2/z045.png "加法函数可以支持多种数据类型")

如果一个 VI，使用变体作为参数数据类型，这样这个 VI 就可以接收任何类型的数据了，这样是不是就可以支持泛型编程了？仅仅只是能够接受不同数据类型是不够的，还要具有类型检查功能才可以支持泛型编程。比如，某一算法可以支持数值和字符串类型的数据，但是不支持布尔类型数据，那么就需要实现这样的功能，当把布尔数据类型于这个算法子 VI 的输入连线的时候，VI 就会立刻报错，不需要运行，VI 就可以提示数据类型出错。 子 VI 使用变体数据类型显然无法做到这一点。甚至更复杂的情况，如果创建了一个字符串类型的数组，再使用其它数组函数（比如插入、索引等）对这个数组操作时，函数应当也只能接收字符串类型的数据，连接到其它数据类型也需要报错。


编程语言主要通过两种方式来支持泛型编程：

一种是以 Java 为代表的类型擦除技术（erasure）。当编译器对带有泛型的 Java 代码进行编译时，会执行数据类型检查和类型推断，如果遇到类型错误会报错。但是编译器生成的执行代码是不带泛型的代码，也就是数据类型信息被擦出了，因此同样一段代码可以被 Java 虚拟机用来处理各种不同类型的数据。这样，Java 的泛型编程即可以及支持多重数据类型，又可以保证类型安全。

比如，在代码中定义了 ​​List\<Int\>​​ 或 ​​List\<String\>​​ 等类型。在代码编译时，编译器会检查传递的数据是否是 Int 或 String 等类型，在代码编译后，它们就都会变成 List。Java 虚拟机看到的只是 List，于是相关的函数不论 List 中数据是何类型，都能正常运行。

另一种是以 C++ 为代表的代码插入技术。在 C++ 中编写泛型函数或者泛型类的时候，其实并非直接编写一个特定的函数或类，而是编写了一个函数或类的模板。比如需要一个支持泛型的 List，那么就要编写一个 List 的模板。程序中使用到了 ​​List\<Int\>​​ 或 ​​List\<String\>​​ 等类型的地方，在编译时，会自动从模板生成对应特定数据类型的代码，插入到应用它的地方。 ​​List\<Int\>​​ 或 ​​List\<String\>​​ ​​生成的是不同的代码，编译程序会在此时确保类型安全性。由于知道数据确切的类型，所以编译器进行代码生成的时候就不用运用动态的类型检查，运行效率较高。但是由于程序中有大量从模板自动生成的代码，代码控件会比较大。与 Java 的泛型支持技术相比，C++ 的技术是以空间换时间。

## 多态VI

## m VI

## 示例