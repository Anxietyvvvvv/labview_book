# 条件结构和顺序结构

## 条件结构

LabVIEW 中的条件结构由多个分支组成，每个分支中有不同的程序代码。条件结构根据输入数据的不同，每次只执行其中一个分支中的代码。这与 C 语言中的 if
else 和 switch 语句的功能相类似。

![](images/image173.png)

图 .14 条件结构

图
3.14 是一个条件结构，它左侧带问号的小矩形是分支选择器。条件结构根据流入分支选择器的数据的值来决定执行某一分支内的代码。条件结构上方带文字的矩形方框是选择标签，文字表示了当前显示的分支的条件。鼠标点击该处，可以修改当前分支的条件；点击向下的三角形，可以按顺序列出选择框所有的分支条件，并切换分支；点击选择标签两侧的小三角，可以依次切换至其它分支。

### 布尔类型条件选择结构

条件结构的一种常见程序模式是：首先比较某个数据，然后把比较的结果传递给分支选择器。条件结构中的两个分支分别是比较结果为 "真"、"假" 时需要执行的代码。如图
3.15 所示。

![](images/image174.png)

图 .15 选择数据为布尔类型

其实，在 LabVIEW 中最为常见的布尔型条件结构是用来处理错误数据线的。（图
3.12 就是一个例子。）这是 LabVIEW 中使用最为普遍的 [错误处理机制](pattern_error_handling)。子 VI 有两个专门用于错误处理的参数："错误输入" 和 "错误输出"。子 VI 中最外层的结构就是一个条件结构，"错误输入" 的数据线直接连至它的分支选择器。如图
3.16 和图 3.17 所示。

若 "错误输入" 是一个错误信息，表示之前的程序已经出错，条件结构执行 "错误" 分支。由于先前程序已出错，这个子 VI 就没有必要再运行后续的功能了，直接把错误信息传递给后续程序即可。所以错误分支中无任何代码。

若 "错误输入" 并非错误信息，表示之前的程序运行正常。条件结构执行 "无错误" 分支。该分支中包含有这个 VI 所需完成的全部功能的代码。

有关错误处理机制的其它内容，将在下一章另行详细阐述。

![](images/image175.png)

图 .16 错误处理的无错误分支

![](images/image176.png)

图 .17 错误处理的错误分支

### 其它数据类型的条件选择

字符串、整数和枚举类型的数据也可以作为条件结构的条件。这些数据类型与布尔数据类型的区别在于，布尔类型数据只可能有两个值："真" 或 "假"；而其余这三种类型的数据，它们的可能值都是无穷的。条件结构不可能为每一可能值都设置一个分支。因此，使用这些数据类型作为条件时，条件结构中必须选择一个分支作为默认分支。如果数据不满足其它分支的条件，就执行默认分支的代码。

对于一个特定的枚举型控件而言，它的数据值的个数是有限的。如果条件结构的条件分支与其项数等同，不设默认分支也可以。但为了避免条件分支少于项数以及在编调过程中增删项引发的错误，最好还是设置默认分支。

条件结构中的一个分支可以对应多个条件，不同条件间用逗号隔开。比如图
3.18 所示条件结构的第三个分支有三个条件，当输入分支选择器的数值为 2、4、6 时，都会执行这一分支。

条件标签还可以是一段值，在两个值之间用两个点连接就表示这两个数值之间的一段值。比如图
3.18 中的第四个分支表示该分支的条件是 7 到 11。当输入数据为 7 至 11 中的任何一个数值时，都会执行这个分支。第五个分支的条件标签表示所有大于等于 12 的数值。用字符串作为条件时，也可以表示一段值，其数值就是与字符串对应的 ASCII 码。

![](images/image177.png)

图 .18 给一个分支添加多个条件

不同分支的条件必须是唯一的。如果同一个条件出现在不同的分支标签中，VI 会报错，并不能运行。

### 合理设置选择条件

利用条件选择器可以接受多种数据类型、每一分支又可以处理多个条件的特点，合理设置条件结构的判断逻辑，可以大大简化代码的复杂度。

比如，要求比较两个输入整数：a 和 b。a>b 时，弹出对话框显示 "a>b"；a=b 时显示 "a=b"；a<b 时显示 "a<b"。编写这个程序并不困难，但是直接按照程序要求的逻辑来编写程序，程序中会出现一个嵌套的条件结构。

![](images/image178.png)

图 .19 嵌套的条件结构

条件结构的可读性也比较差，如果结构有嵌套，可读性会更差。因为程序框图每次只能显示条件结构的一个分支，其它分支的代码需切换到该分支后才能看到。

稍微改动一下程序的条件判断逻辑，即可避免条件结构的嵌套。比如，此例可以改写成图
3.20 所示的代码，用 a、b 的差值来判断它们的大小关系，仅需一个条件结构即可。

![](images/image179.png)

图 .20 改进的条件结构

图
3.20 所示程序的另一处优化，是把每个条件分支中共同的代码 "单按钮对话框" 提取至结构之外，大大改善了程序的可读性和效率。把共同的代码放在结构之外，这个原则在条件结构中是务必遵循的。

再举一个例子，输入 a，b 两个布尔参数，a 和 b 的值在不同情况下完成不同工作。如图
3.21 所示的程序，先把 a 与 b 组成一个布尔数组，再把它转换为数值，从而避免了条件结构嵌套。

![](images/image180.png)

图 .21 多布尔输入值时，使用单一条件结构

## 隧道

与顺序结构相类似，数据在流入流出条件结构时，也要通过隧道。但这两种隧道在使用中并不相同。条件结构的隧道的用法与顺序结构不同。数据流入条件结构的隧道，其输入端在结构外侧，它可以与其它节点的输出端相连接；其输出端在条件结构内侧，条件结构每个分支都可以使用隧道输入端的数据。而数据流出条件结构的隧道则正相反，它的输出端在结构外侧，输入端在结构内侧。虽然条件结构每次只执行其中某一分支的代码，但每个分支都必须为输出隧道的输入端提供一个数据。

每个分支都必须提供一个数据给某隧道，这样编程是比较繁琐的。实际编程中，多数情况下只有在某个分支中才产生一个有意义的数据，供结构外代码使用，其它分支只需提供一个默认值就可以了。

解决这一问题的方案之一是把输出隧道设置为 "未连线时使用默认值"。这样，如果某一分支不传递任何数据给这个输出隧道的输入端，输出隧道就使用该数据类型的默认值作为输出。

在很多场合，条件结构的输出隧道是与某一输入隧道相对应的。如果程序没有特殊说明，流出结构的数据应当与流入结构的数据相同。LabVIEW
8.6 增加了一项新功能，可以把这种有对应关系的输入输出隧道的各个分支，一次性都连接起来。鼠标右键点击输出隧道，选择 "连接输入隧道 -\> 创建并连接未连接的分支"，再用鼠标点击一下输入隧道，即可在每个分支中把输入输出隧道连接起来（图 3.22）。

![](images/image181.png)

图 .22 连接输入输出隧道

## 选择函数

条件结构的可读性比较差，但它又是程序必不可少的一种结构。不过，在某些情况下，可以用选择函数（位于 "编程 -\> 比较 -\> 选择"）代替条件结构。选择函数有三个输入，其中第二个输入参数的数据类型必须是布尔类型；另外两个参数的数据类型必须相同。当输入的第二个参数为 "真" 时，函数把第一个输入参数的值作为输出；否则把第三个输入参数的值作为输出。这类似于 C 语言中的 y=x?a:b;
语句。

如果条件结构的分支选择数据参数为布尔类型，或者可以转换为布尔类型，且每个分支只是用来选择一个不同的数值，则这个条件结构完全可以用选择函数代替。比如，图
3.19 中的条件结构就可以用图 3.23 中的选择函数代替。

![](images/image182.png)

图 .23 使用选择函数改进后的代码

使用选择函数最明显的优点是，所有候选数据都直接展现在程序框图上，用户一眼便可了解整个程序的逻辑，程序可读性大大提高。


## 顺序结构

### 程序执行顺序

LabVIEW 是数据流驱动的编程语言，程序沿着数据在连线上的流动方向顺序执行。LabVIEW 又是自动多线程的编程语言。如果在程序中有两个并行放置、之间无任何连线的模块，则 LabVIEW 会自动把它们放置到不同的线程中，并行执行。

![](images/image160.png)

图 .1 顺序执行的程序

图 3.1 是一个程序顺序执行的例子：数据从控制控件（error
in）接线端流出，流经子 VI"SubVI A" 和 "SubVI B"，最后流入显示控件 "error
out"的接线端。这个程序的执行顺序也就是数据流动的顺序：先运行"SubVI
A"，再运行"SubVI B"。

![](images/image161.png)

图 .2 并行执行的两个 VI

图 3.2 是两个 VI 并行执行的例子：子 VI"SubVI A" 和 "SubVI
B"之间没有数据线相连接，LabVIEW 认为这两个子 VI 没有先后顺序依赖，就会同时运行这两个子 VI。子 VI"Merge
Errors.vi"（打开函数选板" 编程 -\> 对话框与用户界面 -\> 合并错误.vi"，参见其帮助文件。）与"SubVI
A"和"SubVI
B"之间均有数据线相连，它所需的输入数据是由这两个子 VI 输出的。所以这个 VI 的执行顺序是：子 VI"SubVI
A"、"SubVI B"同时开始运行，当它们都执行结束后，子 VI"Merge
Errors.vi" 得到了全部输入数据，开始执行。

### 创建顺序结构

没有数据线相连的各函数或子 VI 之间，也可能需要有执行顺序的依赖关系。比如图
3.2 中的程序，假设 "SubVI A" 完成的工作是在某文件中写入一个数据，而 "SubVI
B"需要从文件中读出此数据。那我们就知道，程序应当按顺序执行完"SubVI
A"，再执行"SubVI
B"。然而，它们之间没有数据线相连，我们需要将它们的顺序关系以另一种方式告诉 LabVIEW。

要让相互之间没有数据线相连的几部分代码，按照特定顺序执行，可以使用顺序结构。在函数选板中选择 "编程 -\> 结构 -\> 平铺式顺序结构" 或 "编程 -\> 结构 -\> 层叠式顺序结构"，就可以在程序框图上放置一个顺序结构。

初次被放置在程序框图上的是一个深灰色的方框，这是一个只有一帧的顺序结构。在顺序结构的右键菜单中选择相关的选项，可以为顺序结构添加新的帧。结构的每一帧内都可以放入程序代码。平铺式顺序结构与层叠式顺序结构的功能完全相同，它们的区别仅仅在于：平铺式顺序结构可以把所有的框架按照从左到右的顺序展开在 VI 的框图上；而层叠式顺序结构的每个框架是重叠的，每一时刻都只有一个框架可以直接在 VI 的框图上显示出来。

当程序运行到顺序结构时，会按照帧的顺序依次执行每一帧。平铺式顺序结构按照从左到右的顺序依次执行每一帧的代码。层叠式顺序结构的框架正上方显示有每一帧的编号，程序按照编号顺序执行每一帧。

在程序框图上放置顺序结构时，可以先在程序框图的空白处放置一个结构，再在结构体内添加代码。也可以把程序框图上已有的代码，直接放置在新添的结构体内。具体操作方法是：在函数选板上，选择顺序结构；然后在程序框图的那些打算放入结构的代码的左上方按下鼠标左键，拖曳出一个包含所有需要放入结构的代码的矩形；释放鼠标，就创建了包含指定代码的结构。过程如图
3.3、图
3.4 所示。（放置顺序结构的这两种操作方式，对 "结构" 选板的其余结构也适用。我们在后面讲述其它结构时，就不再重复了。）

![](images/image162.png)

图 .3 拖拽鼠标，划出矩形范围

![](images/image163.png)

图 .4 添加新的结构，并包含已有代码

### 层叠式顺序结构

假设需要编写一个 VI，用于测试某一段程序代码运行所耗费的时间。考虑的思路是：在被测试代码运行前，记录下当时的系统时间，然后运行被测试代码。被测试代码运行结束时，再记录下新的系统时间。这两个时间之差就是被测代码运行的时间。

由于记录时间的代码部分，与被测试的代码部分并无数据线相连，而它们之间又必须以一定的先后顺序执行，所以可以考虑使用顺序结构。

图 3.5、图 3.6 和图
3.7 分别是这个程序的层叠式顺序结构的三个帧。其中第二帧中的代码是被测试代码。它的功能是，每次循环迭代产生一个随机数，直到这个数字与给定的 "比较数值" 相同，才退出循环。（函数 "时间计数器 (ms)" 位于 "编程 -\> 定时 -\> 时间计数器" 函数选板；
图 3.6 中的函数 "随机数 (0-1)" 位于 "编程 -\> 数值 -\> 随机数" 函数选板。）

![](images/image164.png)

图 .5 第一帧

![](images/image165.png)

图 .6 第二帧

![](images/image166.png)

图 .7 第三帧

在编写这个程序的时候，遇到了一个小麻烦：第三帧需要用到第一帧提供的起始时间。也就是说，在第一帧产生的那个时间数据，需要传递到第三帧中去。由于两个接线端不在同一帧上，无法直接将这两个接线端连线。

在此情况下，需要借助 "顺序局部变量"。在顺序结构的边框上点击鼠标右键，选择 "添加顺序局部变量"，即可为顺序结构创建一个顺序局部变量。该顺序变量在未与输入数据连线时是一个淡黄色的小矩形。把第一帧中 "时间计数器" 函数的输出值与新创建的顺序局部变量相连，数据就传给了它。该顺序局部变量与输入数据线相连后，小矩形内生成了一个与数据线颜色相同的箭头。在后续的那些帧中，可以根据需要，通过连线，把顺序局部变量中的数据引出来。

顺序局部变量上的箭头表示数据流动方向：箭头指向边框表示数据流入；箭头离开边框表示数据流出。在循环结构中，每一个顺序局部变量只能选择其中一帧将数据写入，其后的所有帧都可以从中读取写入的数据。而在这之前的任何帧中，顺序局部变量仍然是个实心矩形，表明在这些帧中，都不能读写它。层叠式顺序结构的代码可读性比较差。在程序框图上，层叠式顺序结构每次只能显示一帧。用户无法直接看到其它帧的代码，因而也难以快速了解整个程序的功能。

流入或流出顺序结构的数据在通过顺序结构时，在结构边框上形成一个颜色与数据线相同的小矩形。这个小矩形叫做隧道，负责把数据传进或传出结构。在层叠式顺序结构中，对于输入隧道，每一帧均可从它读出数据；对于输出隧道，只能有一帧与其相连，写入数据。在其它结构中，也都有隧道，它们的功能十分类似。

当数据进出顺序结构时，在层叠式顺序结构上难以一眼就找到数据接收节点或数据源。比如图 3.6 中，数据从顺序结构流到 "迭代次数"；然而，在图 3.5、图 3.7 中，我们看不到这个数据是如何产生的，只有等到顺序结构切换到第 0 帧，才能找到数据来源。对于这个只有三帧的顺序结构来说，翻看一遍所有的帧，并不困难。但是，如果程序比较复杂，顺序结构超过七八帧以上，要搞清楚整个结构的功能就比较麻烦了。

顺序局部变量的使用，使得层叠式顺序结构的可读性雪上加霜。首先，顺序局部变量与隧道一样，只能通过翻看结构中的每一帧来找到数据源和接收数据的节点。其次，由于一个顺序局部变量在每一帧的位置都是固定的，必然导致某些数据线上数据流动的方向与习惯不符。

大多数人在书写文字的时候，都是按照从左到右的顺序。所以，如果程序也从左到右地执行，就比较符合大多数人的自然习惯。编写 LabVIEW 程序的时候，也应该让所有数据的流动方向是从左到右。也正是遵循了这一原则，几乎所有的 LabVIEW 的函数和子 VI 都把输入参数放在左侧，输出参数放在右侧。

但是数据在流入流出顺序局部变量时，总有一段连线要违背这个原则。例如图
3.5 中的程序，顺序局部变量在左侧，数据从时间计数函数流出后，只好向左流动至顺序局部变量。如果把顺序局部变量放在右侧，写入时数据流动是从左向右了，但图
3.7 读出时数据流动又从右向左了。

### 平铺式顺序结构

在图
3.5 中的顺序结构框上点击鼠标右键，选择 "替换 -\> 替换为平铺式顺序结构"，可以将层叠式顺序结构替换成功能相同的、如图
3.8 所示的平铺式顺序结构。平铺式顺序结构的可读性比层叠式顺序结构好得多。

![](images/image167.png)

图 .8 应用平铺式顺序结构

平铺式顺序结构可以在程序框图上展开显示结构中所有的帧，不再需要使用顺序局部变量。用户对整体程序结构可以一目了然，如在图
3.8 的程序中，一眼就可找到 "迭代次数" 数据的来源。

平铺式顺序结构从左到右依次执行各帧的代码，在每一帧中也是从左到右执行各代码，这样保证了从左至右的整体程序的执行顺序。

平铺式顺序结构的可读性较好。因此，在需要使用顺序结构时，应当首先考虑使用平铺式顺序结构。当然，层叠式顺序结构也有其优点：它占用的程序框图显示面积较小；另外，它可以很方便地调整每一帧的先后顺序（在层叠式顺序结构的右键菜单中选择 "本帧设置为......"）。

### 无形胜有形的最高境界

武侠小说中常常说：练剑的最高境界就是手中无剑。套用到顺序结构上来说，使用顺序结构的最高境界就是不用顺序结构。

以一个简单程序为例：要求在程序中设置一台仪器，再从仪器读取一个数据。但在设置后，需要等待一小段时间，设置才会生效，才可以开始读数为此，我们需要在设置仪器和读取仪器数据之间插入一个一秒钟的延时，以避免读数有误。

![](images/image168.png)

图 .9 一个测试应用程序的代码

图
3.9 所示的程序是不能满足上述要求的。这段程序的延时代码与读写仪器的代码之间没有数据线连接，LabVIEW 就会同时执行这两段代码。所以，尽管这段程序的总运行时间会延迟至 1 秒，但读写部分的代码并不受延时的影响。程序在执行完设置仪器子 VI 后，立即执行读取仪器数据子 VI，致使读取数据错误。

在讲述这个例子是，用到的 "设置仪器.vi" 和 "读仪器数据.vi" 是两个演示用的子 VI，在标签中已表明其功能；"仪器名称" 是输出为句柄类型数据的常量；两个子 VI 之间下方的连线是错误数据线，相关内容将在第 3.2.1 节、第 4.1 节中详细阐述；"等待（ms）" 为 LabVIEW 自带的函数，位于 "编程 -\> 定时 -\> 等待" 函数选板。

如图 3.10 所示，利用顺序结构才可以确保程序的时序正确：

![](images/image169.png)

图 .10 使用顺序结构

其实，图
3.10 中的代码还可以有所改进。在这个程序中，我们只需要保证 "等待" 函数的执行顺序，没必要把其它代码也挪入顺序结构中。改进后的程序如图
3.11 所示：只把 "等待" 函数放入顺序结构中，通过进出顺序结构的数据线控制各子 VI 的执行顺序。改进后的程序，看起来就干净利索多了。

![](images/image170.png)

图 .11 缩小顺序结构的使用范围

大家也许已经注意到，在这个程序中，真正控制程序执行顺序的已经是数据连线，而不再是顺序结构了。代码通过改变数据连线方式，控制数据的流动顺序，从而控制了程序的执行顺序。既然数据连线才是 LabVIEW 中最普遍的控制程序执行顺序的方式，那就完全可以在程序中通过合理布线，替换所有的顺序结构。

回过头来再看一看图
3.11 中的程序，它依然存在着一个比较严重的问题。按照程序的逻辑，程序在执行 "设置仪器" 时，无论是否出错，都得继续执行 "等待" 函数，程序延时 1 秒才会结束。而理想的方案是，一旦 "设置仪器" 时出错，程序应当立即退出。

完成这个功能的最佳方案是，把程序的延时部分做成一个子 VI（图
3.12）。该子 VI 利用条件结构设定，只有 "error
in"输入" 无错误 "时，才执行延时。（在第 3.2.1 节" 条件结构 " 中，我们将详细讲述这种错误选择框的功能和用途。）

![](images/image171.png)

图 .12 延时子 VI

整个程序经过优化后，就成了图
3.13 的样子。我们可以看到，利用错误连线来控制程序执行顺序大大增强了程序的可读性。

![](images/image172.png)

图 .13 使用延时子 VI 的测试程序代码

使用这种方法，移走所有的顺序结构，是使得程序代码更有效更美观的重要手段之一。比如图
3.8 中的程序，我们只要把每一帧中的代码都做成一个子 VI，并且这个子 VI 具有错误输入输出参数。就可以把它们改造成如图
3.13 一样的由几个子 VI 顺序连接组成的简单易懂的程序了。

## 练习

* 找出一个之前编写的 VI，比如某个处理数组数据的 VI，再编写一段程序测量一下这个 VI 的运行时间。

